<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/network.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/yujiosaka/js-mind" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dropoutLayer">dropoutLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-norm">norm</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-randn">randn</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sigmoidPrime">sigmoidPrime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-vectorizedResult">vectorizedResult</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/network.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;

let _ = require(&quot;lodash&quot;);
let linearAlgebra = require(&quot;linear-algebra&quot;)();
let Matrix = linearAlgebra.Matrix;
let lib = require(&quot;./lib&quot;);

class Network {
  constructor(layers) {
    this.layers = layers;
  }

  SGD(trainingData, epochs, miniBatchSize, eta, opts = {}) {
    opts.validationData || (opts.validationData = null);
    opts.testData || (opts.testData = null);
    opts.lmbda || (opts.lmbda = 0);
    let bestValidationAccuracy = 0;
    let testAccuracy = null;

    for (let j of (function() {
        let results = [];

        for (let i = 0; i &lt; epochs; i++) {
            results.push(i);
        }

        return results;
    }).apply(this)) {
      trainingData = _.shuffle(trainingData);
      let miniBatches = this.createMiniBatches(trainingData, miniBatchSize);

      for (let [i, miniBatch] of miniBatches.entries()) {
        let iteration = trainingData.length / miniBatchSize * j + i;
        (iteration % 1000 === 0 ? console.log((&quot;Training mini-batch number &quot; + (iteration))) : undefined);
        this.updateMiniBatch(miniBatch, eta, opts.lmbda, trainingData.length);
      }

      if (opts.validationData) {
        let validationAccuracy = this.accuracy(opts.validationData);
        console.log((&quot;Epoch &quot; + (j) + &quot;: validation accuracy &quot; + (validationAccuracy)));

        if (validationAccuracy &gt;= bestValidationAccuracy) {
          console.log(&quot;This is the best validation accuracy to date.&quot;);
          bestValidationAccuracy = validationAccuracy;

          if (opts.testData) {
            testAccuracy = this.accuracy(opts.testData);
            console.log((&quot;The corresponding test accuracy &quot; + (testAccuracy)));
          }
        }
      } else if (opts.testData) {
        testAccuracy = this.accuracy(opts.testData);
        console.log((&quot;Epoch &quot; + (j) + &quot;: test accuracy &quot; + (testAccuracy)));
      }
    }

    console.log(&quot;Finished training network.&quot;);

    if (opts.validationData) {
      console.log((&quot;Best validation accuracy &quot; + (bestValidationAccuracy)));
      return (opts.testData ? console.log((&quot;Corresponding test accuracy &quot; + (testAccuracy))) : undefined);
    }
  }

  createMiniBatches(trainingData, miniBatchSize) {
    return ((function() {
        let results = [];

        for (let i = 0, ref = trainingData.length; i &lt; ref; i++) {
            results.push(i);
        }

        return results;
    }).apply(this).filter((_, _i) =&gt; {
      return _i === 0 || _i % (miniBatchSize + 1) === 0;
    }).map(k =&gt; {
      return trainingData.slice(k, (k + miniBatchSize));
    }));
  }

  updateMiniBatch(miniBatch, eta, lmbda, n) {
    let x = new Matrix(miniBatch.map(([_x, _y]) =&gt; { return _x.ravel();})).trans();
    let y = new Matrix(miniBatch.map(([_x, _y]) =&gt; { return _y.ravel();})).trans();

    this.train(x, miniBatch.length);
    this.backprop(y);

    return (() =&gt; {
      for (let layer of this.layers) {
        layer.w = layer.w.mulEach(1 - eta * (lmbda / n)).minus((layer.nw.mulEach(eta / miniBatch.length)));
        layer.b = layer.b.minus(layer.nb.mulEach(eta / miniBatch.length));
      }
    })();
  }

  train(x, miniBatchSize) {
    let initLayer = this.layers[0];
    initLayer.setInput(x, x, miniBatchSize);

    return (() =&gt; {
      for (let j of (function() {
          let results = [];

          for (let i = 1, ref = this.layers.length; i &lt; ref; i++) {
              results.push(i);
          }

          return results;
      }).apply(this)) {
        let prevLayer = this.layers[j - 1];
        let layer = this.layers[j];
        layer.setInput(prevLayer.output, prevLayer.outputDropout, miniBatchSize);
      }
    })();
  }

  backprop(y) {
    let lastLayer = this.layers[this.layers.length - 1];
    let delta = lastLayer.costDelta(y);
    lastLayer.update(delta);

    return (() =&gt; {
      for (let l of (function() {
          let results = [];

          for (let i = 2, ref = this.layers.length + 1; (2 &lt;= ref ? i &lt; ref : i &gt; ref); (2 &lt;= ref ? i++ : i--)) {
              results.push(i);
          }

          return results;
      }).apply(this)) {
        let followinglayer = this.layers[this.layers.length - l + 1];
        let layer = this.layers[this.layers.length - l];
        delta = followinglayer.w.trans().dot(delta).mul(lib.sigmoidPrime(layer.z));
        layer.update(delta);
      }
    })();
  }

  accuracy(data) {
    return _.mean(data.map(([x, y]) =&gt; { return this.feedforward(x).accuracy(y); }));
  }

  feedforward(a) {
    this.train(a, 1);
    return this.layers[this.layers.length - 1];
  }

  test(data) {
    return this.accuracy(data);
  }

  predict(inputs) {
    return inputs.map(x =&gt; { return this.feedforward(x).yOut; });
  }
}

module.exports = Network;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
